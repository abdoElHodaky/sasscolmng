// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums
enum UserRole {
  SUPER_ADMIN
  SCHOOL_ADMIN
  TEACHER
  STUDENT
}

enum RoomType {
  CLASSROOM
  LABORATORY
  AUDITORIUM
  CAFETERIA
  LIBRARY
  GYMNASIUM
  OFFICE
  OTHER
}

enum TimeSlotType {
  REGULAR
  BREAK
  LUNCH
  ASSEMBLY
  EXAM
}

enum ScheduleStatus {
  DRAFT
  PENDING_APPROVAL
  APPROVED
  ACTIVE
  ARCHIVED
}

enum SessionType {
  REGULAR
  EXAM
  LAB
  SPECIAL
  MAKEUP
}

enum SessionStatus {
  SCHEDULED
  CONFIRMED
  CANCELLED
  COMPLETED
}

enum ConflictType {
  TEACHER_CONFLICT
  ROOM_CONFLICT
  TIME_CONFLICT
  CAPACITY_CONFLICT
  RESOURCE_CONFLICT
}

enum ConflictSeverity {
  HIGH
  MEDIUM
  LOW
}

enum PreferenceType {
  TEACHER_PREFERENCE
  ROOM_PREFERENCE
  TIME_PREFERENCE
  WORKLOAD_DISTRIBUTION
  SUBJECT_PREFERENCE
  CLASS_PREFERENCE
}

enum EntityType {
  TEACHER
  ROOM
  SUBJECT
  CLASS
  SCHOOL
}

enum RuleType {
  INSTITUTIONAL_POLICY
  TEACHER_AVAILABILITY
  ROOM_AVAILABILITY
  TIME_RESTRICTION
  WORKLOAD_LIMIT
  CONSECUTIVE_PERIODS
}

enum AvailabilityType {
  AVAILABLE
  PREFERRED
  UNAVAILABLE
  LIMITED
}

enum AcademicPeriodType {
  SEMESTER
  QUARTER
  TRIMESTER
  YEAR
}

enum WaitingListStatus {
  PENDING
  IN_PROGRESS
  ASSIGNED
  CANCELLED
}

enum WaitingListPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

// Core Models
model Tenant {
  id          String   @id @default(cuid())
  name        String   @unique
  subdomain   String   @unique
  description String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  schools School[]
  users   User[]

  // Billing relations
  subscriptions Subscription[]
  invoices      Invoice[]
  payments      Payment[]
  usageMetrics  UsageMetric[]

  // Notification relations
  notificationTemplates   NotificationTemplate[]
  notifications           Notification[]
  notificationPreferences NotificationPreference[]

  @@map("tenants")
}

model User {
  id           String    @id @default(cuid())
  email        String    @unique
  password     String
  firstName    String
  lastName     String
  role         UserRole
  isActive     Boolean   @default(true)
  lastLoginAt  DateTime?
  tenantId     String
  schoolId     String?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Relations
  tenant        Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  school        School?        @relation(fields: [schoolId], references: [id], onDelete: SetNull)
  refreshTokens RefreshToken[]

  // Teaching relations
  teacherSubjects    TeacherSubject[]
  teachingSessions   ScheduleSession[] @relation("TeacherSessions")
  createdSchedules   Schedule[]        @relation("ScheduleCreator")
  approvedSchedules  Schedule[]        @relation("ScheduleApprover")
  teacherAvailability TeacherAvailability[]
  createdPreferences SchedulingPreference[] @relation("PreferenceCreator")
  createdRules       SchedulingRule[]       @relation("RuleCreator")
  
  // Schedule versioning relations
  createdVersions    ScheduleVersion[]       @relation("ScheduleVersionCreator")
  versionTeachingSessions ScheduleVersionSession[] @relation("VersionTeacherSessions")

  // Notification relations
  createdTemplates      NotificationTemplate[] @relation("TemplateCreator")
  receivedNotifications Notification[]         @relation("NotificationRecipient")
  notificationPreferences NotificationPreference[]
  waitingListRequests     WaitingList[]           @relation("WaitingListRequester")
  waitingListTeaching     WaitingList[]           @relation("WaitingListTeacher")
  waitingListAssignments  WaitingList[]           @relation("WaitingListAssigner")
  teacherProfile          TeacherProfile?
  studentProfile          StudentProfile?

  @@index([tenantId])
  @@index([schoolId])
  @@index([email])
  @@map("users")
}

model RefreshToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("refresh_tokens")
}

model School {
  id          String   @id @default(cuid())
  name        String
  address     String?
  phone       String?
  email       String?
  website     String?
  description String?
  isActive    Boolean  @default(true)
  tenantId    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  tenant    Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  users     User[]
  subjects  Subject[]
  classes   Class[]
  rooms     Room[]
  schedules Schedule[]
  timeSlots TimeSlot[]
  academicPeriods AcademicPeriod[]
  schedulingPreferences SchedulingPreference[]
  schedulingRules SchedulingRule[]

  // Billing relations
  subscriptions Subscription[]
  waitingLists  WaitingList[]

  @@index([tenantId])
  @@map("schools")
}

model Subject {
  id          String   @id @default(cuid())
  name        String
  code        String
  description String?
  isActive    Boolean  @default(true)
  schoolId    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  school          School           @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  teachers        TeacherSubject[]
  classSubjects   ClassSubject[]
  sessions        ScheduleSession[]
  versionSessions ScheduleVersionSession[]
  waitingLists    WaitingList[]

  @@index([schoolId])
  @@map("subjects")
}

model Class {
  id                String   @id @default(cuid())
  name              String
  grade             Int
  section           String?
  capacity          Int
  currentEnrollment Int      @default(0)
  isActive          Boolean  @default(true)
  schoolId          String
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  school        School           @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  subjects      ClassSubject[]
  sessions      ScheduleSession[]
  versionSessions ScheduleVersionSession[]
  waitingLists  WaitingList[]
  students      StudentProfile[]

  @@index([schoolId])
  @@map("classes")
}

model Room {
  id          String   @id @default(cuid())
  name        String
  type        RoomType
  capacity    Int
  floor       String?
  building    String?
  features    String[] // JSON array of features/equipment
  isActive    Boolean  @default(true)
  schoolId    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  school       School            @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  sessions     ScheduleSession[]
  versionSessions ScheduleVersionSession[]
  waitingLists WaitingList[]

  @@index([schoolId])
  @@map("rooms")
}

// Junction Tables
model TeacherSubject {
  id        String   @id @default(cuid())
  teacherId String
  subjectId String
  createdAt DateTime @default(now())

  // Relations
  user    User    @relation(fields: [teacherId], references: [id], onDelete: Cascade)
  subject Subject @relation(fields: [subjectId], references: [id], onDelete: Cascade)

  @@unique([teacherId, subjectId])
  @@index([teacherId])
  @@index([subjectId])
  @@map("teacher_subjects")
}

model ClassSubject {
  id        String   @id @default(cuid())
  classId   String
  subjectId String
  createdAt DateTime @default(now())

  // Relations
  class   Class   @relation(fields: [classId], references: [id], onDelete: Cascade)
  subject Subject @relation(fields: [subjectId], references: [id], onDelete: Cascade)

  @@unique([classId, subjectId])
  @@index([classId])
  @@index([subjectId])
  @@map("class_subjects")
}

// Scheduling Models
model TimeSlot {
  id          String       @id @default(cuid())
  schoolId    String
  name        String
  dayOfWeek   Int          // 0=Sunday, 1=Monday, ..., 6=Saturday
  startTime   String       // HH:mm format
  endTime     String       // HH:mm format
  duration    Int          // minutes
  type        TimeSlotType @default(REGULAR)
  isActive    Boolean      @default(true)
  order       Int          // sequence in the day
  maxSessions Int?         // max concurrent sessions
  metadata    Json?        // additional metadata
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  // Relations
  school       School            @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  sessions     ScheduleSession[]
  versionSessions ScheduleVersionSession[]
  waitingLists WaitingList[]

  @@index([schoolId])
  @@index([dayOfWeek])
  @@map("time_slots")
}

model AcademicPeriod {
  id        String             @id @default(cuid())
  schoolId  String
  name      String
  startDate DateTime
  endDate   DateTime
  type      AcademicPeriodType
  isActive  Boolean            @default(true)
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt

  // Relations
  school    School     @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  schedules Schedule[]

  @@index([schoolId])
  @@map("academic_periods")
}

model Schedule {
  id                 String         @id @default(cuid())
  schoolId           String
  academicPeriodId   String
  name               String
  description        String?
  startDate          DateTime
  endDate            DateTime
  status             ScheduleStatus @default(DRAFT)
  version            Int            @default(1)
  isActive           Boolean        @default(false)
  createdBy          String
  approvedBy         String?
  approvedAt         DateTime?
  optimizationScore  Float?         // 0-100
  conflictCount      Int            @default(0)
  metadata           Json?          // generation metadata
  createdAt          DateTime       @default(now())
  updatedAt          DateTime       @updatedAt

  // Relations
  school         School            @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  academicPeriod AcademicPeriod    @relation(fields: [academicPeriodId], references: [id], onDelete: Cascade)
  creator        User              @relation("ScheduleCreator", fields: [createdBy], references: [id])
  approver       User?             @relation("ScheduleApprover", fields: [approvedBy], references: [id])
  sessions       ScheduleSession[]
  conflicts      ScheduleConflict[]
  versions       ScheduleVersion[]

  @@index([schoolId])
  @@index([academicPeriodId])
  @@index([status])
  @@map("schedules")
}

model ScheduleSession {
  id               String        @id @default(cuid())
  scheduleId       String
  subjectId        String
  classId          String
  teacherId        String
  roomId           String
  timeSlotId       String
  date             DateTime
  duration         Int           // minutes
  type             SessionType   @default(REGULAR)
  status           SessionStatus @default(SCHEDULED)
  isRecurring      Boolean       @default(false)
  recurrencePattern String?      // cron-like pattern
  notes            String?
  metadata         Json?
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  // Relations
  schedule Schedule @relation(fields: [scheduleId], references: [id], onDelete: Cascade)
  subject  Subject  @relation(fields: [subjectId], references: [id], onDelete: Cascade)
  class    Class    @relation(fields: [classId], references: [id], onDelete: Cascade)
  teacher  User     @relation("TeacherSessions", fields: [teacherId], references: [id], onDelete: Cascade)
  room     Room     @relation(fields: [roomId], references: [id], onDelete: Cascade)
  timeSlot TimeSlot @relation(fields: [timeSlotId], references: [id], onDelete: Cascade)

  @@index([scheduleId])
  @@index([teacherId])
  @@index([roomId])
  @@index([timeSlotId])
  @@index([date])
  @@map("schedule_sessions")
}

model ScheduleConflict {
  id                  String           @id @default(cuid())
  scheduleId          String
  type                ConflictType
  severity            ConflictSeverity
  description         String
  affectedSessionIds  String[]         // array of session IDs
  suggestedResolution String?
  isResolved          Boolean          @default(false)
  resolutionNotes     String?
  resolvedBy          String?
  resolvedAt          DateTime?
  createdAt           DateTime         @default(now())
  updatedAt           DateTime         @updatedAt

  // Relations
  schedule Schedule @relation(fields: [scheduleId], references: [id], onDelete: Cascade)

  @@index([scheduleId])
  @@index([type])
  @@index([severity])
  @@map("schedule_conflicts")
}

model SchedulingPreference {
  id               String         @id @default(cuid())
  schoolId         String
  type             PreferenceType
  entityId         String         // teacherId, roomId, etc.
  entityType       EntityType
  name             String
  description      String?
  weight           Int            // 1-10
  isHardConstraint Boolean        @default(false)
  parameters       Json           // preference parameters
  isActive         Boolean        @default(true)
  createdBy        String
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt

  // Relations
  school  School @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  creator User   @relation("PreferenceCreator", fields: [createdBy], references: [id])

  @@index([schoolId])
  @@index([type])
  @@index([entityId])
  @@map("scheduling_preferences")
}

model SchedulingRule {
  id          String   @id @default(cuid())
  schoolId    String
  name        String
  description String
  type        RuleType
  priority    Int      // 1-10
  isMandatory Boolean  @default(false)
  conditions  Json     // rule conditions
  actions     Json     // actions when violated
  isActive    Boolean  @default(true)
  createdBy   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  school  School @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  creator User   @relation("RuleCreator", fields: [createdBy], references: [id])

  @@index([schoolId])
  @@index([type])
  @@map("scheduling_rules")
}

model TeacherAvailability {
  id            String           @id @default(cuid())
  teacherId     String
  dayOfWeek     Int              // 0=Sunday, 1=Monday, ..., 6=Saturday
  startTime     String           // HH:mm format
  endTime       String           // HH:mm format
  type          AvailabilityType
  maxSessions   Int?             // max sessions during this time
  specificDate  DateTime?        // for one-time changes
  effectiveFrom DateTime
  effectiveTo   DateTime?
  notes         String?
  isActive      Boolean          @default(true)
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  // Relations
  teacher User @relation(fields: [teacherId], references: [id], onDelete: Cascade)

  @@index([teacherId])
  @@index([dayOfWeek])
  @@map("teacher_availability")
}

// ============================================================================
// BILLING SYSTEM MODELS
// ============================================================================

enum BillingPlanType {
  STARTER
  PROFESSIONAL
  ENTERPRISE
  CUSTOM
}

enum BillingCycle {
  MONTHLY
  QUARTERLY
  YEARLY
}

enum SubscriptionStatus {
  ACTIVE
  TRIAL
  PAST_DUE
  CANCELED
  EXPIRED
  PAUSED
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REFUNDED
  PARTIALLY_REFUNDED
}

enum InvoiceStatus {
  DRAFT
  PENDING
  SENT
  PAID
  OVERDUE
  CANCELED
  REFUNDED
}

enum UsageMetricType {
  STUDENTS
  TEACHERS
  CLASSES
  STORAGE_GB
  API_CALLS
  CUSTOM
}

model WaitingList {
  id           String              @id @default(cuid())
  schoolId     String
  subjectId    String
  classId      String
  teacherId    String?
  roomId       String?
  timeSlotId   String?
  priority     WaitingListPriority @default(MEDIUM)
  status       WaitingListStatus   @default(PENDING)
  requestedBy  String
  reason       String
  notes        String?
  requestedAt  DateTime            @default(now())
  assignedAt   DateTime?
  assignedBy   String?
  createdAt    DateTime            @default(now())
  updatedAt    DateTime            @updatedAt

  // Relations
  school       School              @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  subject      Subject             @relation(fields: [subjectId], references: [id], onDelete: Cascade)
  class        Class               @relation(fields: [classId], references: [id], onDelete: Cascade)
  teacher      User?               @relation("WaitingListTeacher", fields: [teacherId], references: [id], onDelete: SetNull)
  room         Room?               @relation(fields: [roomId], references: [id], onDelete: SetNull)
  timeSlot     TimeSlot?           @relation(fields: [timeSlotId], references: [id], onDelete: SetNull)
  requester    User                @relation("WaitingListRequester", fields: [requestedBy], references: [id], onDelete: Cascade)
  assigner     User?               @relation("WaitingListAssigner", fields: [assignedBy], references: [id], onDelete: SetNull)

  @@map("waiting_lists")
}

model TeacherProfile {
  id           String   @id @default(cuid())
  userId       String   @unique
  employeeId   String?  @unique
  department   String?
  specialization String?
  qualification String?
  experience   Int?     // years of experience
  joiningDate  DateTime?
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("teacher_profiles")
}

model StudentProfile {
  id           String   @id @default(cuid())
  userId       String   @unique
  studentId    String?  @unique
  classId      String?
  rollNumber   String?
  admissionDate DateTime?
  guardianName String?
  guardianPhone String?
  guardianEmail String?
  address      String?
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  user  User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  class Class? @relation(fields: [classId], references: [id], onDelete: SetNull)

  @@map("student_profiles")
}

model BillingPlan {
  id                String          @id @default(cuid())
  name              String
  description       String?
  type              BillingPlanType
  monthlyPrice      Decimal         @db.Decimal(10, 2)
  yearlyPrice       Decimal?        @db.Decimal(10, 2)
  currency          String          @default("USD")
  features          Json            // Array of features
  limits            Json            // Usage limits
  isActive          Boolean         @default(true)
  trialDays         Int?            @default(14)
  stripePriceId     String?         // Stripe price ID
  stripeProductId   String?         // Stripe product ID
  metadata          Json?
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt

  // Relations
  subscriptions Subscription[]

  @@index([type])
  @@index([isActive])
  @@map("billing_plans")
}

model Subscription {
  id                    String             @id @default(cuid())
  tenantId              String
  schoolId              String
  planId                String
  status                SubscriptionStatus
  billingCycle          BillingCycle
  currentPeriodStart    DateTime
  currentPeriodEnd      DateTime
  trialStart            DateTime?
  trialEnd              DateTime?
  canceledAt            DateTime?
  cancelAtPeriodEnd     Boolean            @default(false)
  stripeSubscriptionId  String?            // Stripe subscription ID
  stripeCustomerId      String?            // Stripe customer ID
  metadata              Json?
  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt

  // Relations
  tenant       Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  school       School         @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  plan         BillingPlan    @relation(fields: [planId], references: [id])
  invoices     Invoice[]
  payments     Payment[]
  usageMetrics UsageMetric[]

  @@index([tenantId])
  @@index([schoolId])
  @@index([status])
  @@index([currentPeriodEnd])
  @@map("subscriptions")
}

model Invoice {
  id                String        @id @default(cuid())
  subscriptionId    String
  tenantId          String
  invoiceNumber     String        @unique
  status            InvoiceStatus
  subtotal          Decimal       @db.Decimal(10, 2)
  taxAmount         Decimal       @db.Decimal(10, 2) @default(0)
  discountAmount    Decimal       @db.Decimal(10, 2) @default(0)
  total             Decimal       @db.Decimal(10, 2)
  currency          String        @default("USD")
  billingPeriodStart DateTime
  billingPeriodEnd  DateTime
  dueDate           DateTime
  paidAt            DateTime?
  sentAt            DateTime?
  lineItems         Json          // Array of line items
  taxDetails        Json?         // Tax breakdown
  discountDetails   Json?         // Discount details
  stripeInvoiceId   String?       // Stripe invoice ID
  pdfUrl            String?       // URL to PDF invoice
  metadata          Json?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  // Relations
  subscription Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  tenant       Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  payments     Payment[]

  @@index([subscriptionId])
  @@index([tenantId])
  @@index([status])
  @@index([dueDate])
  @@index([invoiceNumber])
  @@map("invoices")
}

model Payment {
  id               String        @id @default(cuid())
  subscriptionId   String
  invoiceId        String?
  tenantId         String
  amount           Decimal       @db.Decimal(10, 2)
  currency         String        @default("USD")
  status           PaymentStatus
  paymentMethod    String?       // card, bank_transfer, etc.
  stripePaymentId  String?       // Stripe payment intent ID
  stripeChargeId   String?       // Stripe charge ID
  failureReason    String?
  refundedAmount   Decimal?      @db.Decimal(10, 2)
  processedAt      DateTime?
  metadata         Json?
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  // Relations
  subscription Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  invoice      Invoice?     @relation(fields: [invoiceId], references: [id])
  tenant       Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([subscriptionId])
  @@index([invoiceId])
  @@index([tenantId])
  @@index([status])
  @@map("payments")
}

model UsageMetric {
  id             String          @id @default(cuid())
  subscriptionId String
  tenantId       String
  metricType     UsageMetricType
  value          Int
  limit          Int?
  periodStart    DateTime
  periodEnd      DateTime
  metadata       Json?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt

  // Relations
  subscription Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  tenant       Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([subscriptionId])
  @@index([tenantId])
  @@index([metricType])
  @@index([periodStart])
  @@map("usage_metrics")
}

// ============================================================================
// NOTIFICATION SYSTEM MODELS
// ============================================================================

enum NotificationType {
  EMAIL
  SMS
  PUSH
  WEBSOCKET
  IN_APP
}

enum NotificationPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

enum NotificationStatus {
  PENDING
  SENT
  DELIVERED
  FAILED
  READ
}

enum TemplateType {
  WELCOME
  INVOICE
  PAYMENT_SUCCESS
  PAYMENT_FAILED
  SUBSCRIPTION_EXPIRED
  TRIAL_ENDING
  SCHEDULE_REMINDER
  CLASS_CANCELED
  CUSTOM
}

model NotificationTemplate {
  id          String       @id @default(cuid())
  tenantId    String?      // null for system templates
  name        String
  type        TemplateType
  subject     String?      // for email templates
  content     String       // template content with variables
  variables   Json         // available variables
  isActive    Boolean      @default(true)
  isSystem    Boolean      @default(false) // system templates cannot be deleted
  metadata    Json?
  createdBy   String?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  // Relations
  tenant        Tenant?        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  creator       User?          @relation("TemplateCreator", fields: [createdBy], references: [id])
  notifications Notification[]

  @@index([tenantId])
  @@index([type])
  @@index([isActive])
  @@map("notification_templates")
}

model Notification {
  id                String               @id @default(cuid())
  tenantId          String
  templateId        String?
  type              NotificationType
  priority          NotificationPriority @default(NORMAL)
  status            NotificationStatus   @default(PENDING)
  recipientId       String               // User ID
  recipientEmail    String?
  recipientPhone    String?
  subject           String?
  message           String               // renamed from content for service compatibility
  content           String?              // keep for backward compatibility
  entityId          String?              // ID of related entity (schedule, class, etc.)
  entityType        String?              // Type of related entity
  scheduledFor      DateTime?            // for scheduled notifications
  scheduledAt       DateTime?            // alias for scheduledFor for service compatibility
  sentAt            DateTime?
  deliveredAt       DateTime?
  readAt            DateTime?
  errorMessage      String?              // renamed from failureReason for service compatibility
  failureReason     String?              // keep for backward compatibility
  attempts          Int                  @default(0)  // renamed from retryCount for service compatibility
  retryCount        Int?                 // keep for backward compatibility
  maxAttempts       Int                  @default(3)  // renamed from maxRetries for service compatibility
  maxRetries        Int?                 // keep for backward compatibility
  metadata          Json?
  createdAt         DateTime             @default(now())
  updatedAt         DateTime             @updatedAt

  // Relations
  tenant    Tenant                @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  template  NotificationTemplate? @relation(fields: [templateId], references: [id])
  recipient User                  @relation("NotificationRecipient", fields: [recipientId], references: [id])

  @@index([tenantId])
  @@index([recipientId])
  @@index([type])
  @@index([status])
  @@index([scheduledFor])
  @@map("notifications")
}

model NotificationPreference {
  id                String             @id @default(cuid())
  userId            String
  tenantId          String
  notificationType  NotificationType
  templateType      TemplateType?      // specific template type preference
  isEnabled         Boolean            @default(true)
  deliveryChannels  Json               // preferred channels for this notification type
  quietHoursStart   String?            // HH:mm format
  quietHoursEnd     String?            // HH:mm format
  timezone          String?
  frequency         String?            // immediate, daily_digest, weekly_digest
  metadata          Json?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt

  // Relations
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([userId, tenantId, notificationType, templateType])
  @@index([userId])
  @@index([tenantId])
  @@map("notification_preferences")
}

// Schedule Versioning Models
model ScheduleVersion {
  id                String        @id @default(cuid())
  scheduleId        String
  version           Int
  name              String
  description       String?
  status            ScheduleStatus
  optimizationScore Float?
  conflictCount     Int           @default(0)
  sessionCount      Int           @default(0)
  createdBy         String
  isActive          Boolean       @default(false)
  metadata          Json?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  // Relations
  schedule  Schedule                   @relation(fields: [scheduleId], references: [id], onDelete: Cascade)
  creator   User                       @relation("ScheduleVersionCreator", fields: [createdBy], references: [id])
  sessions  ScheduleVersionSession[]
  conflicts ScheduleVersionConflict[]

  @@unique([scheduleId, version])
  @@index([scheduleId])
  @@index([version])
  @@index([isActive])
  @@map("schedule_versions")
}

model ScheduleVersionSession {
  id                String        @id @default(cuid())
  scheduleVersionId String
  subjectId         String
  classId           String
  teacherId         String
  roomId            String
  timeSlotId        String
  date              DateTime
  duration          Int           // minutes
  type              SessionType   @default(REGULAR)
  status            SessionStatus @default(SCHEDULED)
  isRecurring       Boolean       @default(false)
  recurrencePattern String?
  notes             String?
  metadata          Json?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  // Relations
  scheduleVersion ScheduleVersion @relation(fields: [scheduleVersionId], references: [id], onDelete: Cascade)
  subject         Subject         @relation(fields: [subjectId], references: [id], onDelete: Cascade)
  class           Class           @relation(fields: [classId], references: [id], onDelete: Cascade)
  teacher         User            @relation("VersionTeacherSessions", fields: [teacherId], references: [id], onDelete: Cascade)
  room            Room            @relation(fields: [roomId], references: [id], onDelete: Cascade)
  timeSlot        TimeSlot        @relation(fields: [timeSlotId], references: [id], onDelete: Cascade)

  @@index([scheduleVersionId])
  @@index([teacherId])
  @@index([roomId])
  @@index([timeSlotId])
  @@index([date])
  @@map("schedule_version_sessions")
}

model ScheduleVersionConflict {
  id                  String           @id @default(cuid())
  scheduleVersionId   String
  type                ConflictType
  severity            ConflictSeverity
  description         String
  affectedSessionIds  String[]         // array of session IDs
  suggestedResolution String?
  isResolved          Boolean          @default(false)
  resolutionNotes     String?
  resolvedBy          String?
  resolvedAt          DateTime?
  createdAt           DateTime         @default(now())
  updatedAt           DateTime         @updatedAt

  // Relations
  scheduleVersion ScheduleVersion @relation(fields: [scheduleVersionId], references: [id], onDelete: Cascade)

  @@index([scheduleVersionId])
  @@index([type])
  @@index([severity])
  @@map("schedule_version_conflicts")
}
